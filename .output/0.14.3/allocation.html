
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Memory allocation &#8212; libcork 0.14.3 documentation</title>
    <link rel="stylesheet" href="_static/docco-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.14.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Error reporting" href="errors.html" />
    <link rel="prev" title="Compiler attributes" href="attributes.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="errors.html" title="Error reporting"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="attributes.html" title="Compiler attributes"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">libcork 0.14.3 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="memory-allocation">
<span id="allocation"></span><h1>Memory allocation<a class="headerlink" href="#memory-allocation" title="Permalink to this headline">¶</a></h1>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;libcork/core.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>One of the biggest hassles in writing C code is memory management.  libcork’s
memory allocation API tries to simplify this task as much as possible.  This is
still C, so you still have to manage allocated memory manually — for instance,
by keeping careful track of which section of code “owns” any memory that you’ve
allocated from heap, and is therefore responsible for freeing it.  But we <em>can</em>
make it easier to handle memory allocation failures, and provide helper macros
for certain common allocation tasks.</p>
<p>There is another <a class="reference external" href="https://blog.mozilla.org/nnethercote/2013/11/08/libraries-should-permit-custom-allocators/">important use case</a> that we also want to support: giving
application writers complete control over how the libraries they use allocate
and deallocate memory.  libcork <a class="reference internal" href="#libcork-allocators"><span class="std std-ref">provides</span></a> this
capability, giving you control over how, for instance, a hash table allocates
its internal buckets.  If you’re writing a library that links with libcork as a
shared library, you’ll get this behavior for free; if the application writer
customizes how libcork allocates memory, your library will pick up that
customization as well.  If you’re embedding libcork, so that your library’s
clients can’t tell (or care) that you’re using libcork, then you’ll want to
expose your own similar customization interface.</p>
<div class="section" id="allocating-memory">
<span id="allocation-api"></span><h2>Allocating memory<a class="headerlink" href="#allocating-memory" title="Permalink to this headline">¶</a></h2>
<p>The simplest part of the API is the part responsible for actually allocating and
deallocating memory.  When using this part of the API, you don’t have to worry
about customization at all; the functions described here will automatically “do
the right thing” based on how your library or application is configured.  The
biggest thing to worry about is how to handle memory allocation failures.  We
provide two strategies, “guaranteed” and “recoverable”.</p>
<p>The most common use case is that running out of memory is a Really Bad Thing,
and there’s nothing we can do to recover.  In this case, it doesn’t make sense
to check for memory allocation failures throughout your code, since you can’t
really do anything if it does happen.  The “guaranteed” family of functions
handles that error checking for you, and guarantees that if the allocation
function returns, it will return a valid piece of memory.  If the allocation
fails, the function will never return.  That allows you to right simple and safe
code like the following:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">my_type</span>  <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="n">cork_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_type</span><span class="p">);</span>
<span class="cm">/* Just start using instance; don&#39;t worry about verifying that it&#39;s</span>
<span class="cm"> * not NULL! */</span>
</pre></div>
</div>
<p>On the other hand, you might be writing some code that can gracefully handle a
memory allocation failure.  You might try to allocate a super-huge cache, for
instance; if you can’t allocate the cache, your code will still work, it will
just be a bit slower.  In this case, you <em>want</em> to be able to detect memory
allocation failures, and handle them in whatever way is appropriate.  The
“recoverable” family of functions will return a <code class="docutils literal"><span class="pre">NULL</span></code> pointer if allocation
fails.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">libcork itself uses the guaranteed functions for all internal memory
allocation.</p>
</div>
<div class="section" id="guaranteed-allocation">
<h3>Guaranteed allocation<a class="headerlink" href="#guaranteed-allocation" title="Permalink to this headline">¶</a></h3>
<p>The functions in this section are guaranteed to return a valid newly allocated
pointer.  If memory allocation fails, the functions will not return.</p>
<dl class="function">
<dt id="c.cork_malloc">
void *<code class="descname">cork_malloc</code><span class="sig-paren">(</span>size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_malloc" title="Permalink to this definition">¶</a></dt>
<dt id="c.cork_calloc">
void *<code class="descname">cork_calloc</code><span class="sig-paren">(</span>size_t<em>&nbsp;count</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_calloc" title="Permalink to this definition">¶</a></dt>
<dt id="c.cork_realloc">
void *<code class="descname">cork_realloc</code><span class="sig-paren">(</span>void<em>&nbsp;*ptr</em>, size_t<em>&nbsp;old_size</em>, size_t<em>&nbsp;new_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_realloc" title="Permalink to this definition">¶</a></dt>
<dt id="c.cork_new">
type *<code class="descname">cork_new</code><span class="sig-paren">(</span>TYPE<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_new" title="Permalink to this definition">¶</a></dt>
<dd><p>The first three functions mimic the standard <code class="docutils literal"><span class="pre">malloc</span></code>, <code class="docutils literal"><span class="pre">calloc</span></code>, and
<code class="docutils literal"><span class="pre">realloc</span></code> functions to allocate (or reallocate) some memory, with the added
guarantee that they will always return a valid newly allocated pointer.
<code class="docutils literal"><span class="pre">cork_new</span></code> is a convenience function for allocating an instance of a
particular type; it is exactly equivalent to:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">cork_malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">type</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that with <code class="docutils literal"><span class="pre">cork_realloc</span></code>, unlike the standard <code class="docutils literal"><span class="pre">realloc</span></code> function,
you must provide the old size of the memory region, in addition to the
requested new size.</p>
<p>Each allocation function has a corresponding deallocation function that you
must use to free the memory when you are done with it: use
<a class="reference internal" href="#c.cork_free" title="cork_free"><code class="xref c c-func docutils literal"><span class="pre">cork_free()</span></code></a> to free memory allocated using <code class="docutils literal"><span class="pre">cork_malloc</span></code> or
<code class="docutils literal"><span class="pre">cork_realloc</span></code>; use <a class="reference internal" href="#c.cork_cfree" title="cork_cfree"><code class="xref c c-func docutils literal"><span class="pre">cork_cfree()</span></code></a> to free memory allocated using
<code class="docutils literal"><span class="pre">cork_calloc</span></code>; and use <a class="reference internal" href="#c.cork_delete" title="cork_delete"><code class="xref c c-func docutils literal"><span class="pre">cork_delete()</span></code></a> to free memory allocated using
<code class="docutils literal"><span class="pre">cork_new</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Note that the possible memory leak in the standard <code class="docutils literal"><span class="pre">realloc</span></code>
function doesn’t apply here, since we’re going to abort the whole
program if the reallocation fails.</p>
</div>
</dd></dl>

</div>
<div class="section" id="recoverable-allocation">
<h3>Recoverable allocation<a class="headerlink" href="#recoverable-allocation" title="Permalink to this headline">¶</a></h3>
<p>The functions in this section will return a <code class="docutils literal"><span class="pre">NULL</span></code> pointer if any memory
allocation fails, allowing you to recover from the error condition, if possible.</p>
<dl class="function">
<dt id="c.cork_xmalloc">
void *<code class="descname">cork_xmalloc</code><span class="sig-paren">(</span>size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_xmalloc" title="Permalink to this definition">¶</a></dt>
<dt id="c.cork_xcalloc">
void *<code class="descname">cork_xcalloc</code><span class="sig-paren">(</span>size_t<em>&nbsp;count</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_xcalloc" title="Permalink to this definition">¶</a></dt>
<dt id="c.cork_xrealloc">
void *<code class="descname">cork_xrealloc</code><span class="sig-paren">(</span>void<em>&nbsp;*ptr</em>, size_t<em>&nbsp;old_size</em>, size_t<em>&nbsp;new_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_xrealloc" title="Permalink to this definition">¶</a></dt>
<dt id="c.cork_xreallocf">
void *<code class="descname">cork_xreallocf</code><span class="sig-paren">(</span>void<em>&nbsp;*ptr</em>, size_t<em>&nbsp;old_size</em>, size_t<em>&nbsp;new_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_xreallocf" title="Permalink to this definition">¶</a></dt>
<dt id="c.cork_xnew">
type *<code class="descname">cork_xnew</code><span class="sig-paren">(</span>TYPE<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_xnew" title="Permalink to this definition">¶</a></dt>
<dd><p>The first three functions mimic the standard <code class="docutils literal"><span class="pre">malloc</span></code>, <code class="docutils literal"><span class="pre">calloc</span></code>,
<code class="docutils literal"><span class="pre">realloc</span></code> functions.  <code class="docutils literal"><span class="pre">cork_xreallocf</span></code> mimics the common <code class="docutils literal"><span class="pre">reallocf</span></code>
function from BSD.  These functions return <code class="docutils literal"><span class="pre">NULL</span></code> if the memory allocation
fails.  (Note that unlike the standard functions, they do <strong>not</strong> set
<code class="docutils literal"><span class="pre">errno</span></code> to <code class="docutils literal"><span class="pre">ENOMEM</span></code>; the only indication you have of an error condition
is a <code class="docutils literal"><span class="pre">NULL</span></code> return value.)</p>
<p>Note that with <code class="docutils literal"><span class="pre">cork_xrealloc</span></code> and <code class="docutils literal"><span class="pre">cork_xreallocf</span></code>, unlike the standard
<code class="docutils literal"><span class="pre">realloc</span></code> function, you must provide the old size of the memory region, in
addition to the requested new size.</p>
<p><code class="docutils literal"><span class="pre">cork_xreallocf</span></code> is more safe than the standard <code class="docutils literal"><span class="pre">realloc</span></code> function.  A
common idiom when calling <code class="docutils literal"><span class="pre">realloc</span></code> is:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span>  <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="cm">/* from somewhere */</span><span class="p">;</span>
<span class="cm">/* UNSAFE!  Do not do this! */</span>
<span class="n">ptr</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
</pre></div>
</div>
<p>This is unsafe!  The <code class="docutils literal"><span class="pre">realloc</span></code> function returns a <code class="docutils literal"><span class="pre">NULL</span></code> pointer if the
reallocation fails.  By assigning directly into <em>ptr</em>, you’ll get a memory
leak in these situations.  The <code class="docutils literal"><span class="pre">cork_xreallocf</span></code> function, on the other
hand, will automatically free the existing pointer if the reallocation fails,
eliminating the memory leak:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span>  <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="cm">/* from somewhere */</span><span class="p">;</span>
<span class="cm">/* This is safe.  Do this. */</span>
<span class="n">ptr</span> <span class="o">=</span> <span class="n">cork_xreallocf</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
<span class="cm">/* Check whether ptr is NULL before using it! */</span>
</pre></div>
</div>
<p>Each allocation function has a corresponding deallocation function that you
must use to free the memory when you are done with it: use
<a class="reference internal" href="#c.cork_free" title="cork_free"><code class="xref c c-func docutils literal"><span class="pre">cork_free()</span></code></a> to free memory allocated using <code class="docutils literal"><span class="pre">cork_xmalloc</span></code>,
<code class="docutils literal"><span class="pre">cork_xrealloc</span></code>, or <code class="docutils literal"><span class="pre">cork_xreallocf</span></code>; use <a class="reference internal" href="#c.cork_cfree" title="cork_cfree"><code class="xref c c-func docutils literal"><span class="pre">cork_cfree()</span></code></a> to free
memory allocated using <code class="docutils literal"><span class="pre">cork_xcalloc</span></code>; and use <a class="reference internal" href="#c.cork_delete" title="cork_delete"><code class="xref c c-func docutils literal"><span class="pre">cork_delete()</span></code></a> to
free memory allocated using <code class="docutils literal"><span class="pre">cork_xnew</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="deallocation">
<h3>Deallocation<a class="headerlink" href="#deallocation" title="Permalink to this headline">¶</a></h3>
<p>Since this is C, you must free any memory region once you’re done with it.
You must use one of the functions from this section to free any memory that you
created using any of the allocation functions described previously.</p>
<dl class="function">
<dt id="c.cork_free">
void *<code class="descname">cork_free</code><span class="sig-paren">(</span>void<em>&nbsp;*ptr</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_free" title="Permalink to this definition">¶</a></dt>
<dt id="c.cork_cfree">
void *<code class="descname">cork_cfree</code><span class="sig-paren">(</span>void<em>&nbsp;*ptr</em>, size_t<em>&nbsp;count</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_cfree" title="Permalink to this definition">¶</a></dt>
<dt id="c.cork_delete">
type *<code class="descname">cork_delete</code><span class="sig-paren">(</span>void<em>&nbsp;*ptr</em>, TYPE<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Frees a region of memory allocated by one of libcork’s allocation functions.</p>
<p>Note that unlike the standard <code class="docutils literal"><span class="pre">free</span></code> function, you must provide the size of
the allocated region when it’s freed, as well as when it’s created.  Most of
the time this isn’t an issue, since you’re either freeing a region whose size
is known at compile time, or you’re already keeping track of the size of a
dynamically sized memory region for some other reason.</p>
<p>You should use <code class="docutils literal"><span class="pre">cork_free</span></code> to free memory allocated using
<a class="reference internal" href="#c.cork_malloc" title="cork_malloc"><code class="xref c c-func docutils literal"><span class="pre">cork_malloc()</span></code></a>, <a class="reference internal" href="#c.cork_realloc" title="cork_realloc"><code class="xref c c-func docutils literal"><span class="pre">cork_realloc()</span></code></a>, <a class="reference internal" href="#c.cork_xmalloc" title="cork_xmalloc"><code class="xref c c-func docutils literal"><span class="pre">cork_xmalloc()</span></code></a>,
<a class="reference internal" href="#c.cork_xrealloc" title="cork_xrealloc"><code class="xref c c-func docutils literal"><span class="pre">cork_xrealloc()</span></code></a>, or <a class="reference internal" href="#c.cork_xreallocf" title="cork_xreallocf"><code class="xref c c-func docutils literal"><span class="pre">cork_xreallocf()</span></code></a>.  You should use
<code class="docutils literal"><span class="pre">cork_cfree</span></code> to free memory allocated using <a class="reference internal" href="#c.cork_calloc" title="cork_calloc"><code class="xref c c-func docutils literal"><span class="pre">cork_calloc()</span></code></a> or
<a class="reference internal" href="#c.cork_xcalloc" title="cork_xcalloc"><code class="xref c c-func docutils literal"><span class="pre">cork_xcalloc()</span></code></a>.  You should use <code class="docutils literal"><span class="pre">cork_delete</span></code> to free memory
allocated using <a class="reference internal" href="#c.cork_new" title="cork_new"><code class="xref c c-func docutils literal"><span class="pre">cork_new()</span></code></a> or <a class="reference internal" href="#c.cork_xnew" title="cork_xnew"><code class="xref c c-func docutils literal"><span class="pre">cork_xnew()</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="duplicating-strings">
<h3>Duplicating strings<a class="headerlink" href="#duplicating-strings" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.cork_strdup">
const char *<code class="descname">cork_strdup</code><span class="sig-paren">(</span>const char<em>&nbsp;*str</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_strdup" title="Permalink to this definition">¶</a></dt>
<dt id="c.cork_strndup">
const char *<code class="descname">cork_strndup</code><span class="sig-paren">(</span>const char<em>&nbsp;*str</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_strndup" title="Permalink to this definition">¶</a></dt>
<dt id="c.cork_xstrdup">
const char *<code class="descname">cork_xstrdup</code><span class="sig-paren">(</span>const char<em>&nbsp;*str</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_xstrdup" title="Permalink to this definition">¶</a></dt>
<dt id="c.cork_xstrndup">
const char *<code class="descname">cork_xstrndup</code><span class="sig-paren">(</span>const char<em>&nbsp;*str</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_xstrndup" title="Permalink to this definition">¶</a></dt>
<dd><p>These functions mimic the standard <code class="docutils literal"><span class="pre">strdup</span></code> function.  They create a copy
of an existing C string, allocating exactly as much memory is needed to hold
the copy.</p>
<p>The <code class="docutils literal"><span class="pre">strdup</span></code> variants calculate the size of <em>str</em> using <code class="docutils literal"><span class="pre">strlen</span></code>.  For
the <code class="docutils literal"><span class="pre">strndup</span></code> variants, <em>str</em> does not need to be <code class="docutils literal"><span class="pre">NUL</span></code>-terminated, and
you must pass in its <em>size</em>.  (Note that is different than the standard
<code class="docutils literal"><span class="pre">strndup</span></code>, where <em>str</em> must be <code class="docutils literal"><span class="pre">NUL</span></code>-terminated, and which copies <strong>at
most</strong> <em>size</em> bytes.  Our version always copies <strong>exactly</strong> <em>size</em> bytes.)
The result is guaranteed to be <code class="docutils literal"><span class="pre">NUL</span></code>-terminated, even if the source <em>str</em>
is not.</p>
<p>You shouldn’t modify the contents of the copied string.  You must use
<a class="reference internal" href="#c.cork_strfree" title="cork_strfree"><code class="xref c c-func docutils literal"><span class="pre">cork_strfree()</span></code></a> to free the string when you’re done with it.  The
<code class="docutils literal"><span class="pre">x</span></code> variant returns a <code class="docutils literal"><span class="pre">NULL</span></code> pointer if the allocation fails; the non-<code class="docutils literal"><span class="pre">x</span></code> variant is guaranteed to return a valid pointer to a copied string.</p>
</dd></dl>

<dl class="function">
<dt id="c.cork_strfree">
void <code class="descname">cork_strfree</code><span class="sig-paren">(</span>const char<em>&nbsp;*str</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_strfree" title="Permalink to this definition">¶</a></dt>
<dd><p>Frees <em>str</em>, which must have been created using
<a class="reference internal" href="#c.cork_strdup" title="cork_strdup"><code class="xref c c-func docutils literal"><span class="pre">cork_strdup()</span></code></a> or <a class="reference internal" href="#c.cork_xstrdup" title="cork_xstrdup"><code class="xref c c-func docutils literal"><span class="pre">cork_xstrdup()</span></code></a>.</p>
</dd></dl>

</div>
</div>
<div class="section" id="customizing-how-libcork-allocates">
<span id="libcork-allocators"></span><h2>Customizing how libcork allocates<a class="headerlink" href="#customizing-how-libcork-allocates" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal"><span class="pre">cork_alloc</span></code> type encapsulates a particular memory allocation scheme.  To
customize how libcork allocates memory, you create a new instance of this type,
and then use <a class="reference internal" href="#c.cork_set_allocator" title="cork_set_allocator"><code class="xref c c-func docutils literal"><span class="pre">cork_set_allocator()</span></code></a> to register it with libcork.</p>
<dl class="function">
<dt id="c.cork_set_allocator">
void <code class="descname">cork_set_allocator</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.cork_alloc" title="cork_alloc">cork_alloc</a><em>&nbsp;*alloc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_set_allocator" title="Permalink to this definition">¶</a></dt>
<dd><p>Override which <a class="reference internal" href="#allocators"><span class="std std-ref">allocator instance</span></a> libcork will use to
create and free memory.  We will take control of <em>alloc</em>; you must not free
it yourself after passing it to this function.</p>
<p>You can only call this function at most once.  This function is <strong>not</strong>
thread-safe; it’s only safe to call before you’ve called <strong>any</strong> other
libcork function (or any function from any other library that uses libcork.
(The only exceptions are libcork functions that take in a
<a class="reference internal" href="#c.cork_alloc" title="cork_alloc"><code class="xref c c-type docutils literal"><span class="pre">cork_alloc</span></code></a> parameter or return a <a class="reference internal" href="#c.cork_alloc" title="cork_alloc"><code class="xref c c-type docutils literal"><span class="pre">cork_alloc</span></code></a> result; these
functions are safe to call before calling <code class="docutils literal"><span class="pre">cork_set_allocator</span></code>.)</p>
</dd></dl>

<dl class="var">
<dt id="c.cork_allocator">
const struct <a class="reference internal" href="#c.cork_alloc" title="cork_alloc">cork_alloc</a> *<code class="descname">cork_allocator</code><a class="headerlink" href="#c.cork_allocator" title="Permalink to this definition">¶</a></dt>
<dd><p>The current <a class="reference internal" href="#allocators"><span class="std std-ref">allocator instance</span></a> that libcork will use to
create and free memory.</p>
</dd></dl>

<div class="section" id="writing-a-custom-allocator">
<span id="allocators"></span><h3>Writing a custom allocator<a class="headerlink" href="#writing-a-custom-allocator" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.cork_alloc">
struct <code class="descname">cork_alloc</code><a class="headerlink" href="#c.cork_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal"><span class="pre">cork_alloc</span></code> type contains several methods for performing different
allocation and deallocation operations.</p>
<p>You are only required to provide implementations of <code class="docutils literal"><span class="pre">xmalloc</span></code> and <code class="docutils literal"><span class="pre">free</span></code>;
we can provide default implementations of all of the other methods in terms
of those two.  You can provide optimized versions of the other methods, if
appropriate.</p>
</dd></dl>

<dl class="function">
<dt id="c.cork_alloc_new_alloc">
struct <a class="reference internal" href="#c.cork_alloc" title="cork_alloc">cork_alloc</a> *<code class="descname">cork_alloc_new_alloc</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.cork_alloc" title="cork_alloc">cork_alloc</a><em>&nbsp;*parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_alloc_new_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">cork_alloc_new</span></code> creates a new allocator instance.  The new instance will
itself be allocated using <em>parent</em>.  You must provide implementations of at
least the <code class="docutils literal"><span class="pre">xmalloc</span></code> and <code class="docutils literal"><span class="pre">free</span></code> methods.  You can also override our
default implementations of any of the other methods.</p>
<p>This function is <strong>not</strong> thread-safe; it’s only safe to call before you’ve
called <strong>any</strong> other libcork function (or any function from any other library
that uses libcork.  (The only exceptions are libcork functions that take in a
<a class="reference internal" href="#c.cork_alloc" title="cork_alloc"><code class="xref c c-type docutils literal"><span class="pre">cork_alloc</span></code></a> parameter or return a <a class="reference internal" href="#c.cork_alloc" title="cork_alloc"><code class="xref c c-type docutils literal"><span class="pre">cork_alloc</span></code></a> result; these
functions are safe to call before calling <code class="docutils literal"><span class="pre">cork_set_allocator</span></code>.)</p>
<p>The new allocator instance will automatically be freed when the process
exits.  If you registered a <em>user_data</em> pointer for your allocation methods
(via <a class="reference internal" href="#c.cork_alloc_set_user_data" title="cork_alloc_set_user_data"><code class="xref c c-func docutils literal"><span class="pre">cork_alloc_set_user_data()</span></code></a>), it will be freed using the
<em>free_user_data</em> method you provided.  If you create more than one
<code class="docutils literal"><span class="pre">cork_alloc</span></code> instance in the process, they will be freed in the reverse
order that they were created.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In your allocator implementation, you cannot assume that the rest of the
libcork allocation framework has been set up yet.  So if your allocator
needs to allocate, you must not use the usual <a class="reference internal" href="#c.cork_malloc" title="cork_malloc"><code class="xref c c-func docutils literal"><span class="pre">cork_malloc()</span></code></a> family
of functions; instead you should use the <code class="docutils literal"><span class="pre">cork_alloc_malloc</span></code> variants to
explicitly allocate memory using your new allocator’s <em>parent</em>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.cork_alloc_set_user_data">
void <code class="descname">cork_alloc_set_user_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.cork_alloc" title="cork_alloc">cork_alloc</a><em>&nbsp;*alloc</em>, void<em>&nbsp;*user_data</em>, <a class="reference internal" href="array.html#c.cork_free_f" title="cork_free_f">cork_free_f</a><em>&nbsp;free_user_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_alloc_set_user_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide a <em>user_data</em> pointer, which will be passed unmodified to each
allocation method that you register.  You can also provide an optional
<em>free_user_data</em> method, which we will use to free the <em>user_data</em> instance
when the allocator itself is freed.</p>
</dd></dl>

<dl class="function">
<dt id="c.cork_alloc_set_calloc">
void <code class="descname">cork_alloc_set_calloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.cork_alloc" title="cork_alloc">cork_alloc</a><em>&nbsp;*alloc</em>, <a class="reference internal" href="#c.cork_alloc_calloc_f" title="cork_alloc_calloc_f">cork_alloc_calloc_f</a><em>&nbsp;calloc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_alloc_set_calloc" title="Permalink to this definition">¶</a></dt>
<dt id="c.cork_alloc_set_xcalloc">
void <code class="descname">cork_alloc_set_xcalloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.cork_alloc" title="cork_alloc">cork_alloc</a><em>&nbsp;*alloc</em>, <a class="reference internal" href="#c.cork_alloc_calloc_f" title="cork_alloc_calloc_f">cork_alloc_calloc_f</a><em>&nbsp;calloc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_alloc_set_xcalloc" title="Permalink to this definition">¶</a></dt>
<dd><dl class="type">
<dt id="c.cork_alloc_calloc_f">
void *<code class="descname">(*cork_alloc_calloc_f)</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.cork_alloc" title="cork_alloc">cork_alloc</a><em>&nbsp;*alloc</em>, size_t<em>&nbsp;count</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_alloc_calloc_f" title="Permalink to this definition">¶</a></dt>
<dd><p>These methods are used to implement the <a class="reference internal" href="#c.cork_calloc" title="cork_calloc"><code class="xref c c-func docutils literal"><span class="pre">cork_calloc()</span></code></a> and
<a class="reference internal" href="#c.cork_xcalloc" title="cork_xcalloc"><code class="xref c c-func docutils literal"><span class="pre">cork_xcalloc()</span></code></a> functions.  Your must allocate and return <code class="docutils literal"><span class="pre">count</span> <span class="pre">*</span>
<span class="pre">size</span></code> bytes of memory.  You must ensure that every byte in this region is
initialized to <code class="docutils literal"><span class="pre">0</span></code>.  The <code class="docutils literal"><span class="pre">calloc</span></code> variant must always return a valid
pointer; if memory allocation fails, it must not return.  The <code class="docutils literal"><span class="pre">xcalloc</span></code>
variant should return <code class="docutils literal"><span class="pre">NULL</span></code> if allocation fails.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="c.cork_alloc_set_malloc">
void <code class="descname">cork_alloc_set_malloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.cork_alloc" title="cork_alloc">cork_alloc</a><em>&nbsp;*alloc</em>, <a class="reference internal" href="#c.cork_alloc_malloc_f" title="cork_alloc_malloc_f">cork_alloc_malloc_f</a><em>&nbsp;malloc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_alloc_set_malloc" title="Permalink to this definition">¶</a></dt>
<dt id="c.cork_alloc_set_xmalloc">
void <code class="descname">cork_alloc_set_xmalloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.cork_alloc" title="cork_alloc">cork_alloc</a><em>&nbsp;*alloc</em>, <a class="reference internal" href="#c.cork_alloc_malloc_f" title="cork_alloc_malloc_f">cork_alloc_malloc_f</a><em>&nbsp;malloc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_alloc_set_xmalloc" title="Permalink to this definition">¶</a></dt>
<dd><dl class="type">
<dt id="c.cork_alloc_malloc_f">
void *<code class="descname">(*cork_alloc_malloc_f)</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.cork_alloc" title="cork_alloc">cork_alloc</a><em>&nbsp;*alloc</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_alloc_malloc_f" title="Permalink to this definition">¶</a></dt>
<dd><p>These methods are used to implement the <a class="reference internal" href="#c.cork_malloc" title="cork_malloc"><code class="xref c c-func docutils literal"><span class="pre">cork_malloc()</span></code></a> and
<a class="reference internal" href="#c.cork_xmalloc" title="cork_xmalloc"><code class="xref c c-func docutils literal"><span class="pre">cork_xmalloc()</span></code></a> functions.  You must allocate and return <em>size</em>
bytes of memory.  The <code class="docutils literal"><span class="pre">malloc</span></code> variant must always return a valid
pointer; if memory allocation fails, it must not return.  The <code class="docutils literal"><span class="pre">xmalloc</span></code>
variant should return <code class="docutils literal"><span class="pre">NULL</span></code> if allocation fails.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="c.cork_alloc_set_realloc">
void <code class="descname">cork_alloc_set_realloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.cork_alloc" title="cork_alloc">cork_alloc</a><em>&nbsp;*alloc</em>, <a class="reference internal" href="#c.cork_alloc_realloc_f" title="cork_alloc_realloc_f">cork_alloc_realloc_f</a><em>&nbsp;realloc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_alloc_set_realloc" title="Permalink to this definition">¶</a></dt>
<dt id="c.cork_alloc_set_xrealloc">
void <code class="descname">cork_alloc_set_xrealloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.cork_alloc" title="cork_alloc">cork_alloc</a><em>&nbsp;*alloc</em>, <a class="reference internal" href="#c.cork_alloc_realloc_f" title="cork_alloc_realloc_f">cork_alloc_realloc_f</a><em>&nbsp;realloc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_alloc_set_xrealloc" title="Permalink to this definition">¶</a></dt>
<dd><dl class="type">
<dt id="c.cork_alloc_realloc_f">
void *<code class="descname">(*cork_alloc_realloc_f)</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.cork_alloc" title="cork_alloc">cork_alloc</a><em>&nbsp;*alloc</em>, void<em>&nbsp;*ptr</em>, size_t<em>&nbsp;old_size</em>, size_t<em>&nbsp;new_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_alloc_realloc_f" title="Permalink to this definition">¶</a></dt>
<dd><p>These methods are used to implement the <a class="reference internal" href="#c.cork_realloc" title="cork_realloc"><code class="xref c c-func docutils literal"><span class="pre">cork_realloc()</span></code></a>,
<a class="reference internal" href="#c.cork_xrealloc" title="cork_xrealloc"><code class="xref c c-func docutils literal"><span class="pre">cork_xrealloc()</span></code></a>, and <a class="reference internal" href="#c.cork_xreallocf" title="cork_xreallocf"><code class="xref c c-func docutils literal"><span class="pre">cork_xreallocf()</span></code></a> functions.  You
must reallocate <em>ptr</em> to contain <em>new_size</em> bytes of memory and return the
reallocated pointer.  <em>old_size</em> will be the previously allocated size of
<em>ptr</em>.  The <code class="docutils literal"><span class="pre">realloc</span></code> variant must always return a valid pointer; if
memory reallocation fails, it must not return.  The <code class="docutils literal"><span class="pre">xrealloc</span></code> variant
should return <code class="docutils literal"><span class="pre">NULL</span></code> if reallocation fails.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="c.cork_alloc_set_free">
void <code class="descname">cork_alloc_set_free</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.cork_alloc" title="cork_alloc">cork_alloc</a><em>&nbsp;*alloc</em>, <a class="reference internal" href="#c.cork_alloc_free_f" title="cork_alloc_free_f">cork_alloc_free_f</a><em>&nbsp;free</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_alloc_set_free" title="Permalink to this definition">¶</a></dt>
<dd><dl class="type">
<dt id="c.cork_alloc_free_f">
void *<code class="descname">(*cork_alloc_free_f)</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.cork_alloc" title="cork_alloc">cork_alloc</a><em>&nbsp;*alloc</em>, void<em>&nbsp;*ptr</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cork_alloc_free_f" title="Permalink to this definition">¶</a></dt>
<dd><p>These methods are used to implement the <a class="reference internal" href="#c.cork_free" title="cork_free"><code class="xref c c-func docutils literal"><span class="pre">cork_free()</span></code></a>,
<a class="reference internal" href="#c.cork_cfree" title="cork_cfree"><code class="xref c c-func docutils literal"><span class="pre">cork_cfree()</span></code></a>, and <a class="reference internal" href="#c.cork_delete" title="cork_delete"><code class="xref c c-func docutils literal"><span class="pre">cork_delete()</span></code></a> functions.  You must
deallocate <em>ptr</em>.  <em>size</em> will be the allocated size of <em>ptr</em>.</p>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Memory allocation</a><ul>
<li><a class="reference internal" href="#allocating-memory">Allocating memory</a><ul>
<li><a class="reference internal" href="#guaranteed-allocation">Guaranteed allocation</a></li>
<li><a class="reference internal" href="#recoverable-allocation">Recoverable allocation</a></li>
<li><a class="reference internal" href="#deallocation">Deallocation</a></li>
<li><a class="reference internal" href="#duplicating-strings">Duplicating strings</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-how-libcork-allocates">Customizing how libcork allocates</a><ul>
<li><a class="reference internal" href="#writing-a-custom-allocator">Writing a custom allocator</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="attributes.html"
                        title="previous chapter">Compiler attributes</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="errors.html"
                        title="next chapter">Error reporting</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/allocation.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="errors.html" title="Error reporting"
             >next</a> |</li>
        <li class="right" >
          <a href="attributes.html" title="Compiler attributes"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">libcork 0.14.3 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2011-2012, RedJack, LLC.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.5.
    </div>
  </body>
</html>